# TypeScript テストルール

## テストフレームワーク
- **Vitest**: このプロジェクトではVitestを使用
- テストのインポート: `import { describe, it, expect, beforeEach, vi } from 'vitest'`
- モックの作成: `vi.mock()` を使用

## テストの基本方針

### 品質要件
- **カバレッジ**: 単体テストのカバレッジは70%以上を必須
- **独立性**: 各テストは他のテストに依存せず実行可能
- **再現性**: テストは環境に依存せず、常に同じ結果を返す
- **可読性**: テストコードも製品コードと同様の品質を維持

### カバレッジ要件
**必須**: 単体テストのカバレッジは70%以上
**指標**: Statements（文）、Branches（分岐）、Functions（関数）、Lines（行）

### テストの種類と範囲
1. **単体テスト（Unit Tests）**
   - 個々の関数やクラスの動作を検証
   - 外部依存はすべてモック化
   - 最も数が多く、細かい粒度で実施

2. **統合テスト（Integration Tests）**
   - 複数のコンポーネントの連携を検証
   - 実際の依存関係を使用（DBやAPI等）
   - 主要な機能フローの検証

## Red-Green-Refactorプロセス（テストファースト開発）

**推奨原則**: コード変更は必ずテストから始める

**背景**: 
- 変更前の動作を保証し、リグレッションを防止
- 期待する動作を明確化してから実装
- リファクタリング時の安全性を確保

**開発ステップ**:
1. **Red**: 期待する動作のテストを書く（失敗する）
2. **Green**: 最小限の実装でテストを通す
3. **Refactor**: テストが通る状態を維持しながらコード改善

**NGケース（テストファースト不要）**:
- 純粋な設定ファイル変更（.env、config等）
- ドキュメントのみの更新（README、コメント等）
- 緊急本番障害対応（ただし事後テスト必須）

## テストの設計原則

### テストケースの構造
- テストは「準備（Arrange）」「実行（Act）」「検証（Assert）」の3段階で構成
- 各テストの目的が明確に分かる命名
- 1つのテストケースでは1つの振る舞いのみを検証

### テストデータ管理
- テストデータは専用ディレクトリで管理
- 環境変数はテスト用の値を定義
- 機密情報は必ずモック化
- テストデータは最小限に保ち、テストケースの検証目的に直接関連するデータのみ使用

### モックとスタブの使用方針

✅ **推奨: 単体テストでの外部依存モック化**
- メリット: テストの独立性と再現性を確保
- 実践: DB、API、ファイルシステム等の外部依存をモック化

❌ **避けるべき: 単体テストでの実際の外部接続**
- 理由: テスト速度が遅くなり、環境依存の問題が発生するため

### テスト失敗時の対応判断基準

**テストを修正**: 間違った期待値、存在しない機能参照、実装詳細への依存、テストのためだけの実装
**実装を修正**: 妥当な仕様、ビジネスロジック、重要なエッジケース
**判断に迷ったら**: ユーザーに確認

## テストヘルパーの活用ルール

### 基本原則
テストヘルパーは、テストコードの重複を減らし、保守性を高めるために活用します。

### 判断基準
| モックの特性 | 対応方針 |
|-------------|---------|
| **単純で安定** | 共通ヘルパーに集約 |
| **複雑または変更頻度高** | 個別実装 |
| **3箇所以上で重複** | 共通化を検討 |
| **テスト固有ロジック** | 個別実装 |

### テストヘルパー活用例
```typescript
// ✅ 推奨: ビルダーパターンの活用
const testData = new TestDataBuilder()
  .withDefaults()
  .withName('Test User')
  .build()

// ✅ 推奨: カスタムアサーション
function assertValidUser(user: unknown): asserts user is User {
  // バリデーションロジック
}

// ❌ 避ける: 重複する複雑なモックの個別実装
```

## テストの実装規約

### ディレクトリ構造
```
src/
└── application/
    └── services/
        ├── __tests__/
        │   ├── service.test.ts      # 単体テスト
        │   └── service.int.test.ts  # 統合テスト
        └── service.ts
```

### 命名規則
- テストファイル: `{対象ファイル名}.test.ts`
- 統合テストファイル: `{対象ファイル名}.int.test.ts`
- テストスイート: 対象の機能や状況を説明する名前
- テストケース: 期待される動作を説明する名前


### テストコードの品質ルール

✅ **推奨: すべてのテストを常に有効に保つ**
- メリット: テストスイートの完全性を保証
- 実践: 問題があるテストは修正して有効化

❌ **避けるべき: test.skip()やコメントアウト**
- 理由: テストの穴が生まれ、品質チェックが不完全になる
- 対処: 不要なテストは完全に削除する

## テストの粒度

### 原則：観測可能な振る舞いのみ
**テスト対象**：公開API、戻り値、例外、外部呼び出し、永続化された状態
**テスト対象外**：privateメソッド、内部状態、アルゴリズム詳細

```typescript
// ✅ 振る舞いをテスト
expect(calculatePrice(100, 0.1)).toBe(110)

// ❌ 実装詳細をテスト
expect((calculator as any).taxRate).toBe(0.1)
```

## モックの型安全性

### 必要最小限の型定義
```typescript
// ✅ 必要な部分のみ
type TestRepo = Pick<Repository, 'find' | 'save'>
const mock: TestRepo = { find: vi.fn(), save: vi.fn() }

// やむを得ない場合のみ、理由明記
const sdkMock = {
  call: vi.fn()
} as unknown as ExternalSDK // 外部SDKの複雑な型のため
```

## Vitestの基本例

```typescript
import { describe, it, expect, beforeEach, vi } from 'vitest'

// モックの設定例
vi.mock('./userService', () => ({
  getUserById: vi.fn(),
  updateUser: vi.fn()
}))

describe('ComponentName', () => {
  it('should follow AAA pattern', () => {
    // Arrange
    const input = 'test'
    
    // Act
    const result = someFunction(input)
    
    // Assert
    expect(result).toBe('expected')
  })
})
```