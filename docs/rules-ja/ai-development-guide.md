# AI開発者ガイド - 技術的判断基準とアンチパターン集

## 技術的アンチパターン（赤信号パターン）

以下のパターンを検出したら即座に停止し、設計を見直すこと：

### コード品質のアンチパターン
1. **同じようなコードを3回以上書いた** - Rule of Threeに違反
2. **単一ファイルに複数の責務が混在** - 単一責任原則（SRP）違反
3. **同じ内容を複数ファイルで定義** - DRY原則違反
4. **依存関係を確認せずに変更** - 予期しない影響の可能性
5. **コメントアウトでコード無効化** - バージョン管理を活用すべき
6. **エラーの握りつぶし** - 問題の隠蔽は技術的負債
7. **型アサーション（as）の多用** - 型安全性の放棄

### 設計のアンチパターン
- **「一旦動くように」という思考** - 技術的負債の蓄積
- **継ぎ足し実装** - 既存コードへの無計画な追加
- **不確実技術の楽観的実装** - 未知要素を「たぶん動く」前提で設計
- **対処療法的修正** - 根本原因を解決しない表面的な修正
- **無計画な大規模変更** - 段階的アプローチの欠如

## フォールバック処理に関する設計原則

### 基本原則：Fail-Fast
分散システムにおいて、フォールバック処理よりもプライマリコードの信頼性向上を優先する設計思想。

### フォールバック実装の判断基準
- **原則禁止**: エラー時の無条件フォールバックは実装しない
- **例外的許可**: Design Docで明示的に定義された場合のみ実装
- **レイヤー責務**:
  - インフラ層: エラーを必ず上位に投げる（フォールバック判断なし）
  - アプリケーション層: ビジネス要件に基づく判断を実装

### フォールバック過多の検出
- 同一機能で3つ目のcatch文を書く時点で設計見直しを必須とする
- フォールバックを実装する前にDesign Docでの定義を確認
- エラーは適切にログ出力し、失敗を明確にする

## Rule of Three - コード重複の判断基準

Martin Fowler「Refactoring」に基づく重複コードの扱い方：

| 重複回数 | 対応 | 理由 |
|---------|------|------|
| 1回目 | インライン実装 | 将来の変化が予測できない |
| 2回目 | 将来の統合を意識 | パターンが見え始める |
| 3回目 | 共通化実施 | パターンが確立された |

### 共通化の判断基準

**共通化すべきケース**
- ビジネスロジックの重複
- 複雑な処理アルゴリズム
- 一括変更が必要になる可能性が高い箇所
- バリデーションルール

**共通化を避けるべきケース**
- 偶然の一致（たまたま同じコード）
- 将来異なる方向に進化する可能性
- 共通化により可読性が著しく低下
- テストコード内の簡単なヘルパー

### 実装例
```typescript
// ❌ 1回目の重複で即共通化
function validateUserEmail(email: string) { /* ... */ }
function validateContactEmail(email: string) { /* ... */ }

// ✅ 3回目で共通化
function validateEmail(email: string, context: 'user' | 'contact' | 'admin') { /* ... */ }
```

## よくある失敗パターンと回避方法

### パターン1: エラー修正の連鎖
**症状**: エラーを修正すると新しいエラーが発生
**原因**: 根本原因を理解せずに表面的な修正
**回避方法**: 5 Whysで根本原因を特定してから修正

### パターン2: 型安全性の放棄
**症状**: any型やasの多用
**原因**: 型エラーを回避したい衝動
**回避方法**: unknown型と型ガードで安全に処理

### パターン3: テスト不足での実装
**症状**: 実装後にバグ多発
**原因**: Red-Green-Refactorプロセスの無視
**回避方法**: 必ず失敗するテストから開始

### パターン4: 技術的不確実性の無視
**症状**: 新技術導入時の想定外エラー多発
**原因**: 事前調査なしで「公式ドキュメント通りなら動くはず」
**回避方法**: 
- タスクファイル冒頭に確実性評価を記載
  ```
  確実性: low（理由: MCP接続の実例がない）
  探索的実装: true
  フォールバック: 従来APIを使用
  ```
- 確実性lowの場合、最初に最小限の動作確認コードを作成
- 動作確認できたら本実装、できなければフォールバック実行

### パターン5: 既存コード調査不足
**症状**: 重複実装、アーキテクチャ不整合、結合時の障害
**原因**: 実装前の既存コード理解不足
**回避方法**: 
- 実装前に類似機能の存在を必ず検索（同じドメイン、責務、設定パターンをキーワードに）
- 類似機能を発見 → その実装を使用する（新規実装は行わない）
- 類似機能が技術的負債 → ADRで改善提案を作成してから実装
- 類似機能が存在しない → 既存の設計思想に沿って新規実装
- すべての判断と根拠をDesign Docの「既存コードベース分析」セクションに記録

## デバッグ手法

### 1. エラー分析手順
1. エラーメッセージ（最初の行）を正確に読む
2. スタックトレースの最初と最後に注目
3. 自分のコードが現れる最初の行を特定

### 2. 5 Whys - 根本原因分析
```
症状: TypeScriptのビルドエラー
Why1: 型定義が一致しない → Why2: インターフェースが更新された
Why3: 依存関係の変更 → Why4: パッケージ更新の影響
Why5: 破壊的変更を含むメジャーバージョンアップ
根本原因: package.jsonでのバージョン指定が不適切
```

### 3. 最小再現コード
問題を切り分けるため、最小限のコードで再現を試みる：
- 関連のない部分を削除
- モックで外部依存を置き換え
- 問題が再現する最小構成を作成

### 4. デバッグログ出力
```typescript
console.log('DEBUG:', {
  context: 'user-creation',
  input: { email, name },
  state: currentState,
  timestamp: new Date().toISOString()
})
```

## 品質チェックコマンドリファレンス

### Phase 1-3: 基本チェック
```bash
# Biome総合チェック（lint + format）
npm run check

# 未使用エクスポートの検出
npm run check:unused

# TypeScriptビルド
npm run build
```

### Phase 4-6: テストと最終確認
```bash
# テスト実行
npm test

# カバレッジ測定（キャッシュクリア）
npm run test:coverage:fresh

# 全体統合チェック
npm run check:all
```

### 補助コマンド
```bash
# カバレッジレポート確認
open coverage/index.html

# Vitestプロセスのクリーンアップ（テスト後必須）
npm run cleanup:processes

# 安全なテスト実行（自動クリーンアップ付き）
npm run test:safe

# 自動修正
npm run format        # フォーマット修正
npm run lint:fix      # Lint修正
```

### トラブルシューティング
- **ポート使用中エラー**: `npm run cleanup:processes`
- **キャッシュ問題**: `npm run test:coverage:fresh`
- **依存関係エラー**: `npm ci`で再インストール

## 技術的判断が必要な場面

### 抽象化のタイミング
- 具体的な実装を3回書いてからパターンを抽出
- YAGNIを意識し、現在必要な機能のみ実装
- 将来の拡張性より現在のシンプルさを優先

### パフォーマンス vs 可読性
- 明確なボトルネックがない限り可読性を優先
- 計測してから最適化（推測するな、計測せよ）
- 最適化する場合はコメントで理由を明記

### 型定義の粒度
- 過度に細かい型は保守性を低下させる
- ドメインを適切に表現する型を設計
- ユーティリティ型を活用して重複を削減

## 継続的改善のマインドセット

- **謙虚**: 完璧なコードは存在しない、フィードバック歓迎
- **勇気**: 必要なリファクタリングは大胆に実行
- **透明性**: 技術的な判断理由を明確に記録

## 実装作業の完全性担保

### 影響範囲調査の必須手順

**完了定義**: 以下3段階すべての完了

#### 1. 検索（Discovery）
```bash
Grep -n "TargetClass\|TargetMethod" -o content
Grep -n "DependencyClass" -o content
Grep -n "targetData\|SetData\|UpdateData" -o content
```

#### 2. 読解（Understanding）
**必須**: 発見した全ファイルを読み込み、作業に必要な部分をコンテキストに含める：
- 呼び出し元の目的と文脈
- 依存関係の方向
- データフロー: 生成→変更→参照

#### 3. 特定（Identification）
影響範囲の構造化報告（必須）：
```
## 影響範囲分析
### 直接影響: ClassA、ClassB（理由明記）
### 間接影響: SystemX、PrefabY（連携経路明記）
### 処理フロー: 入力→処理1→処理2→出力
```

**重要**: 検索のみで完了とせず、3段階すべてを実行すること

### 未使用コード削除ルール

未使用コード検出時 → 使用予定？
- Yes → 即実装（保留禁止）
- No → 即削除（Git履歴に残る）

対象: コード・ドキュメント・設定ファイル

### 既存コード削除判断フロー

```
使用中？ No → 即削除（Git履歴に残る）
      Yes → 動作？ No → 削除+再実装
                  Yes → 修正
```