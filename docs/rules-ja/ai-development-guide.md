# AI開発者ガイド - 技術的判断基準とアンチパターン集

このドキュメントは、LLM（あなた）が実装時に参照すべき技術的な判断基準、アンチパターン、デバッグ手法、品質チェックコマンドをまとめたものです。本ドキュメントは純粋に技術的なガイダンスに特化します。

## 技術的アンチパターン（赤信号パターン）

以下のパターンを検出したら即座に停止し、設計を見直すこと：

### コード品質のアンチパターン
1. **同じようなコードを3回以上書いた** - Rule of Threeに違反
2. **単一ファイルに複数の責務が混在** - 単一責任原則（SRP）違反
3. **同じ内容を複数ファイルで定義** - DRY原則違反
4. **依存関係を確認せずに変更** - 予期しない影響の可能性
5. **コメントアウトでコード無効化** - バージョン管理を活用すべき
6. **エラーの握りつぶし** - 問題の隠蔽は技術的負債
7. **型アサーション（as）の多用** - 型安全性の放棄

### 設計のアンチパターン
- **「一旦動くように」という思考** - 技術的負債の蓄積
- **継ぎ足し実装** - 既存コードへの無計画な追加
- **不確実技術の楽観的実装** - 未知要素を「たぶん動く」前提で設計
- **対処療法的修正** - 根本原因を解決しない表面的な修正
- **無計画な大規模変更** - 段階的アプローチの欠如

## Rule of Three - コード重複の判断基準

Martin Fowler「Refactoring」に基づく重複コードの扱い方：

| 重複回数 | 対応 | 理由 |
|---------|------|------|
| 1回目 | インライン実装 | 将来の変化が予測できない |
| 2回目 | 将来の統合を意識 | パターンが見え始める |
| 3回目 | 共通化実施 | パターンが確立された |

### 共通化の判断基準

**共通化すべきケース**
- ビジネスロジックの重複
- 複雑な処理アルゴリズム
- 一括変更が必要になる可能性が高い箇所
- バリデーションルール

**共通化を避けるべきケース**
- 偶然の一致（たまたま同じコード）
- 将来異なる方向に進化する可能性
- 共通化により可読性が著しく低下
- テストコード内の簡単なヘルパー

### 実装例
```typescript
// ❌ 悪い例: 1回目の重複で即共通化
function validateUserEmail(email: string) { /* ... */ }
function validateContactEmail(email: string) { /* ... */ }
// → 早すぎる抽象化

// ✅ 良い例: 3回目で共通化
// 1回目: inline実装
// 2回目: コピーだが将来を意識
// 3回目: 共通バリデーターに抽出
function validateEmail(email: string, context: 'user' | 'contact' | 'admin') { /* ... */ }
```

## よくある失敗パターンと回避方法

### パターン1: エラー修正の連鎖
**症状**: エラーを修正すると新しいエラーが発生
**原因**: 根本原因を理解せずに表面的な修正
**回避方法**: 5 Whysで根本原因を特定してから修正

### パターン2: 型安全性の放棄
**症状**: any型やasの多用
**原因**: 型エラーを回避したい衝動
**回避方法**: unknown型と型ガードで安全に処理

### パターン3: テスト不足での実装
**症状**: 実装後にバグ多発
**原因**: Red-Green-Refactorプロセスの無視
**回避方法**: 必ず失敗するテストから開始

### パターン4: 技術的不確実性の無視
**症状**: 新技術導入時の想定外エラー多発
**原因**: 事前調査なしで「公式ドキュメント通りなら動くはず」
**回避方法**: 
- タスクファイル冒頭に確実性評価を記載
  ```
  確実性: low（理由: MCP接続の実例がない）
  探索的実装: true
  フォールバック: 従来APIを使用
  ```
- 確実性lowの場合、最初に最小限の動作確認コードを作成
- 動作確認できたら本実装、できなければフォールバック実行

### パターン5: 既存コード調査不足
**症状**: 重複実装、アーキテクチャ不整合、結合時の障害
**原因**: 実装前の既存コード理解不足
**回避方法**: 
- 実装前に類似機能の存在を必ず検索（同じドメイン、責務、設定パターンをキーワードに）
- 類似機能を発見 → その実装を使用する（新規実装は行わない）
- 類似機能が技術的負債 → ADRで改善提案を作成してから実装
- 類似機能が存在しない → 既存の設計思想に沿って新規実装
- すべての判断と根拠をDesign Docの「既存コードベース分析」セクションに記録

## デバッグ手法

### 1. エラー分析手順
```bash
# スタックトレースの読み方
1. エラーメッセージ（最初の行）を正確に読む
2. スタックトレースの最初と最後に注目
3. 自分のコードが現れる最初の行を特定
```

### 2. 5 Whys - 根本原因分析
```
症状: TypeScriptのビルドエラー
Why1: 型定義が一致しない → Why2: インターフェースが更新された
Why3: 依存関係の変更 → Why4: パッケージ更新の影響
Why5: 破壊的変更を含むメジャーバージョンアップ
根本原因: package.jsonでのバージョン指定が不適切
```

### 3. 最小再現コード
問題を切り分けるため、最小限のコードで再現を試みる：
- 関連のない部分を削除
- モックで外部依存を置き換え
- 問題が再現する最小構成を作成

### 4. デバッグのためのログ出力
```typescript
// 構造化ログで問題を追跡
console.log('DEBUG:', {
  context: 'user-creation',
  input: { email, name },
  state: currentState,
  timestamp: new Date().toISOString()
})
```

## 品質チェックコマンドリファレンス

### Phase 1-3: 基本チェック
```bash
# Biome総合チェック（lint + format）
npm run check

# 未使用エクスポートの検出
npm run check:unused

# TypeScriptビルド
npm run build
```

### Phase 4-6: テストと最終確認
```bash
# テスト実行
npm test

# カバレッジ測定（キャッシュクリア）
npm run test:coverage:fresh

# 全体統合チェック
npm run check:all
```

### 補助コマンド
```bash
# カバレッジレポート確認
open coverage/index.html

# Vitestプロセスのクリーンアップ（テスト後必須）
npm run cleanup:processes

# 安全なテスト実行（自動クリーンアップ付き）
npm run test:safe

# 自動修正
npm run format        # フォーマット修正
npm run lint:fix      # Lint修正
```

### トラブルシューティング
- **ポート使用中エラー**: `npm run cleanup:processes`
- **キャッシュ問題**: `npm run test:coverage:fresh`
- **依存関係エラー**: `npm ci`で再インストール

## 技術的判断が必要な場面

### 抽象化のタイミング
- 具体的な実装を3回書いてからパターンを抽出
- YAGNIを意識し、現在必要な機能のみ実装
- 将来の拡張性より現在のシンプルさを優先

### パフォーマンス vs 可読性
- 明確なボトルネックがない限り可読性を優先
- 計測してから最適化（推測するな、計測せよ）
- 最適化する場合はコメントで理由を明記

### 型定義の粒度
- 過度に細かい型は保守性を低下させる
- ドメインを適切に表現する型を設計
- ユーティリティ型を活用して重複を削減

## 継続的改善のマインドセット

- **謙虚**: 完璧なコードは存在しない、フィードバック歓迎
- **勇気**: 必要なリファクタリングは大胆に実行
- **透明性**: 技術的な判断理由を明確に記録