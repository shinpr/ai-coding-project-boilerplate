# 技術設計ルール

このルールファイルは、プロジェクトの技術的なアーキテクチャ設計、データフロー設計、環境設定に関するルールとガイドラインを定義します。

## 技術スタックの基本方針
TypeScriptをベースとしたアプリケーション開発。アーキテクチャパターンはプロジェクトの要件と規模に応じて選択すること。

## 環境変数管理とセキュリティ

### 環境変数管理
- 環境変数は一元管理し、型安全性を確保する仕組みを構築すること
- `process.env` の直接参照は避け、設定管理層を通じて取得すること
- デフォルト値の設定や必須チェックを適切に実装すること

### セキュリティ
- `.env`ファイルはGitに含めない
- APIキーやシークレットは必ず環境変数として管理
- 機密情報のログ出力は禁止
- エラーメッセージに機密情報を含めない

## アーキテクチャ設計

### アーキテクチャの選択と定義
このプロジェクトのアーキテクチャは `docs/architecture/` に定義されています。

#### 新規プロジェクトの場合
1. `docs/rules/architecture/` から適切なアーキテクチャパターンを選択
2. 選んだパターンを `docs/architecture/` にコピー
3. プロジェクトの要件に合わせてカスタマイズ

#### 既存プロジェクトの場合
1. 必ず `docs/architecture/` を確認
2. 定義されたルールとパターンに厳密に従う
3. アーキテクチャの一貫性を最優先とする

### アーキテクチャパターンの例
- **Vertical Slice Architecture**: LLM最適化、1機能1ファイル原則
- **Hybrid Progressive Architecture**: 小規模から大規模への段階的進化

詳細は `docs/rules/architecture/` を参照。

<!-- 参照例:
@docs/rules/architecture/vertical-slice/rules.md - LLM最適化、1機能1ファイル原則
@docs/rules/architecture/hybrid-progressive/rules.md - 小規模から大規模への段階的進化
-->

## 依存性注入（DI）パターン

### 概要
依存性注入（Dependency Injection）パターンの活用により：
- テスタビリティの向上
- モジュール間の疎結合
- 実装の入れ替えが容易

### 実装方法
プロジェクトの規模と要件に応じて、適切なDIパターンまたはDIライブラリを選択すること。

## 設計ドキュメントとプロセス

### PRD/ADR/Design Doc/作業計画書作成プロセス

#### 作成が必要なケース
1. **新機能追加時**: PRD → ADR（アーキテクチャ変更がある場合） → Design Doc → 作業計画書 → 実装
2. **大規模変更時（6ファイル以上）**: ADR → Design Doc → 作業計画書（必須） → 実装
3. **中規模変更時（3-5ファイル）**: Design Doc作成を検討 → 作業計画書（推奨） → 実装
4. **小規模修正時（1-2ファイル）**: 直接実装

#### 作業計画書について
- **保存場所**: `docs/plans/`（.gitignoreで除外）
- **命名規則**: `YYYYMMDD-{feature|fix|refactor}-{brief-description}.md`
- **テンプレート**: `docs/plans/template.md`
- **運用フロー**: 
  1. 中規模以上の変更開始時に作成
  2. 各フェーズ完了時に進捗更新（チェックボックス）
  3. 全タスク完了後、ユーザー承認を得て削除

#### ADR（Architecture Decision Record）
ADR作成プロセスと運用方法については @docs/rules/architecture-decision-process.md を参照。

### データフロー統一原則

#### 基本原則
1. **単一データソース**: 同じ情報は1箇所にのみ保存する
2. **構造化データ優先**: JSON文字列ではなくパース済みオブジェクトを使用
3. **明確な責務分離**: 各層の責務を明確に定義
4. **型安全性の確保**: `unknown`型の使用は外部入力の初期受け取り時のみに限定し、必ず型ガードで検証後に具体的な型に変換

#### データフローのベストプラクティス
- **入力時点での検証**: データは入力層で検証し、型安全な形で内部に渡す
- **変換の一元化**: データ変換ロジックは専用のユーティリティに集約
- **エラーハンドリングの一貫性**: 各層で発生したエラーはその層で処理し、上位層には抽象化されたエラーを返す
- **ログの構造化**: データフローの各段階で構造化ログを出力

## ビルドとテスト

ビルドコマンドとテスト実行については @docs/rules/typescript-testing.md を参照。
品質チェックの詳細については @docs/rules/ai-development-guide.md の「品質チェック（実装完了時必須）」を参照。