# クイックスタート - AIと一緒に開発を始めよう

このガイドでは、AI コーディングプロジェクトボイラープレートを使って、最初の機能を実装するまでの手順を説明します。難しいことは後回しにして、まずは動かしてみましょう。

## セットアップ（5分で完了）

### 新規プロジェクトを始める場合

ターミナルを開いて、以下のコマンドを実行するだけです。プロジェクト名は好きなものに変えてください。

```bash
npx create-ai-project my-awesome-project --lang=ja
cd my-awesome-project
npm install
```

これで準備完了です。`my-awesome-project` というフォルダが作られ、必要なファイルがすべて揃った状態になります。

### 既存のプロジェクトに導入する場合

すでにTypeScriptプロジェクトがある場合は、プロジェクトのルートディレクトリで以下を実行します：

```bash
npx create-ai-project update
```

エージェント定義、コマンド、スキル、AIルールがプロジェクトに追加されます。ソースコードや`package.json`は変更されません。

## Claude Codeを起動して最初の設定

プロジェクトディレクトリで Claude Code を起動します。

```bash
claude
```

起動したら、まずプロジェクトの前提情報を設定します。ここで設定した情報は毎セッション開始時にAIが読み込み、実行精度の向上に使われます。

Claude Codeに以下のコマンド（カスタムスラッシュコマンド）を入力します。

```bash
/project-inject
```

対話的に、プロジェクトの情報を収集していきます。以下の内容が聞かれます：
- プロジェクトが何をするか、どのドメインに属するか
- AIの判断に影響するドメイン固有の制約
- 開発フェーズやディレクトリ規約

収集した情報は `.claude/skills/project-context/SKILL.md` に保存されます。後から`/project-inject`を再実行して更新できます。

## 最初の機能を実装してみよう

さあ、実際に機能を作ってみましょう。Claude Codeに作成したい機能の内容をコマンド付きで入力してみてください。

```bash
/implement Helloと返す簡単なAPIを作成したいです。
```

/implementコマンドを使うと、設計から実装までの一連の作業を順に進めてくれます。

まず、あなたの要求を分析して、どのくらいの規模の機能なのかを判定します。「これは3ファイルくらいの中規模な機能です」といった具合です。規模に応じて、必要な設計書を作成していきます。

小さな機能なら簡単な計画書だけ、大きな機能ならPRD（プロダクト要求仕様書）からDesign Doc（技術設計書）まで順次作成していきます。各設計書の作成が終わると、自動的にドキュメントのレビューが実施されます。

レビューが終わり設計書ができると、AIが「こんな設計にしましたが、確認してもらえますか？」と聞いてきます。内容を読んで、気になる点があれば修正をお願いできます。問題なければ承認してください。
利用しているClaude Codeのモデルによっては、レビューの結果が良好であった場合に次の設計書の作成に進むことがあります。どこかのタイミングではあなたに承認を求めてくるので、その場合はまとめて修正指示を出してください。

設計が承認されると、次は結合テストのスケルトンと作業計画書が作られます。実装の手順が示されますので、確認（必要に応じて修正依頼）して承認すると、いよいよ実装が始まります。

AIは作業計画を1コミットの単位にタスク分解して、1タスクずつTDDアプローチで自律的に実装していきます。各タスクが終わるごとに定められた6ステップの品質チェックを行い、エラーを修正し、問題がなければコミットを作成します。あなたは進捗を眺めているだけで大丈夫です。

すべてのタスクが完了すると、「実装が完了しました」と報告してくれます。`git log` を見ると、きれいにコミットが積み重なっているはずです。

## このボイラープレートの開発思想

最後に、このボイラープレートがどんな考え方で作られているかを説明します。

AI活用によるスループットを最大化するためには、極力人間が介入する場面を減らすことが重要です。
ですが、AIの実行精度を最大化しようとするとコンテキスト管理が非常に重要になるため、適切なタイミングで適切な情報を与えなくてはならず、仕組みを整えなければ人が付き添い実装を進める必要が生じます。そうなってはスループットは最大化できません。

そこで、このボイラープレートでは、各フェーズに対して適切なコンテキスト（スキル、要件、仕様）が選択されること、タスクの実行には不要となる情報を制限すること、これらを仕組みで解決しようとしています。

まずは設計書を作り、それをユーザーとレビューし、認識を揃える。その設計書をコンテキストとして作業を計画し、タスクを作る。タスクの実行は専用のコンテキストを持つサブエージェントが担うことで、タスクに不要な情報が入らず実装が安定する。このような仕組みにすることで、コーディングエージェント単体ではコンテキストウィンドウに収まらないような規模な開発でも品質を保ちながら進められるようになります（Claude Opus 4.1では200Kトークン、Sonnet 4ではベータ版で1Mトークンまで対応していますが、基本は200Kトークンという制限があります）。

詳しい仕組みについては、[こちらの記事](https://qiita.com/shinpr/items/98771c2b8d2e15cafcd5)で解説されています。興味があれば読んでみてください。

## 次のステップ

セットアップが完了したら、よくあるカスタマイズのやり方を確認しておきましょう。

| やりたいこと | 方法 |
|---|---|
| AIにライブラリのドキュメント（llms.txt、APIリファレンス等）を参照させたい | 既存スキルに追記するか、[新規作成](./skills-editing-guide.md) — [判断例はこちら](#例ライブラリドキュメントの置き場所) |
| チームのコーディング規約をAIに守らせたい | ルールを記載した[カスタムスキルを作成](./skills-editing-guide.md) |
| プロジェクト固有の制約やコンテキストを設定したい | `/project-inject`を実行 |
| 利用可能なコマンドの全体像を知りたい | [ユースケース＆コマンド](./use-cases.md) |
| エージェントの振る舞いをカスタマイズしたい | `.claude/skills/`配下のスキルファイルを編集 |

プロジェクト固有の知識をAIに伝えるにはスキルが一番手軽です。作り方は[スキル編集ガイド](./skills-editing-guide.md)を参照してください。

### 例：ライブラリドキュメントの置き場所

ライブラリのドキュメント（`llms.txt`のURL等）をどこに置くかは、プロジェクトでの使われ方によって変わります。**AIがいつその情報を必要とするか**と**何と関連が深いか**で判断してください。既存スキルへの追記、フェーズ固有のドキュメントへの記載、専用スキルの作成など、いくつかのパターンがあります。具体的な判断例は[ユースケースガイド](./use-cases.md#aiにライブラリのドキュメントを参照させたいときは)に、詳しい判断基準は[スキル編集ガイド](./skills-editing-guide.md#どのファイルに記載するべきかの判断基準)にまとめています。

## トラブルシューティング

うまくいかないときは、以下を確認してください。

**実装が途中で止まった場合**
「/implement Design Doc作成まで終わっているので、続きから再開して実装まで完遂してください」のように、現在の状態を伝えて再開を依頼してください。
