---
description: ユーザーのスキル変更要求を精度最大化して実装
---

**コマンドコンテキスト**: スキルファイルの変更要求を理解し、精度最大化して実装するワークフロー

変更要求: $ARGUMENTS

## 実行プロセス

以下のステップをTodoWriteに登録し、順番に進行する。

### Step 1: 変更要求の理解

未指定時はAskUserQuestionで確認：
- どのスキルを変更するか（例: typescript-rules / coding-standards）
- 変更種別: 新基準追加 / 既存基準修正 / 基準削除
- 具体的な変更内容

対象ファイル特定：
- スキル名が明示 → Read: `.claude/skills/{スキル名}/SKILL.md`
- 部分的に判明 → Glob: `.claude/skills/*{キーワード}*/SKILL.md`
- 不明 → Glob: `.claude/skills/*/SKILL.md` で全件確認 → ユーザーに選択

### Step 2: 変更設計案の作成

現状と変更案のbefore/afterを提示：

```
【現状】
"エラーは適切に処理する"（曖昧：「適切」の基準不明）

【変更案】
"エラーハンドリング実装基準：
1. try-catch必須条件：外部API呼び出し、ファイルI/O、JSON.parse等
2. エラーログ必須項目：error.name、error.stack、タイムスタンプ"

この設計で進めますか？ (y/n)
```

**設計の9観点チェックリスト**:
1. 最小記述で最大精度（コンテキスト効率）
2. スキルファイル内・間の重複排除
3. 関連内容は1ファイルに集約（読み込み回数最小化）
4. 測定可能な判断基準（if-then形式）
5. NG例は背景情報として推奨形式に変換
6. 一貫した表記
7. 暗黙前提を明示化
8. 記述順序: 冒頭＝最重要、末尾＝例外
9. スコープ境界: 扱う/扱わない範囲を明示

### Step 3: 3回見直しプロセス

1. **追記モード**: 曖昧表現→測定可能基準、暗黙前提→明示条件、エッジケース定義（最低5項目追記）
2. **批判的修正モード**: 重複統合、過度な詳細を簡潔化、他スキルとの重複→参照に置換（修正前後の差分を記録）
3. **復元判定モード**: 精度低下リスクがある削除→復元、妥当な削除→維持

最終確認：「ユーザーの変更要求を正確に実装するための必要十分条件が揃っているか？」

### Step 4: 承認取得と実装

1. 変更前後の比較をユーザーに提示し承認を取得
2. 適切なツールで変更適用
3. git diffで変更内容を最終確認
4. `/sync-skills` 実行を提案

## 完了条件

- [ ] 対象スキルを特定し現状を把握した
- [ ] 変更設計案を9観点でレビューした
- [ ] 3回見直しプロセスを完了した
- [ ] ユーザー承認を取得した
- [ ] 変更を適用しgit diffで確認した
- [ ] /sync-skills実行を提案した

## エラーハンドリング

| エラー | アクション |
|--------|-----------|
| スキル未発見 | 利用可能なスキル一覧を表示 |
| 大規模変更検出（50%以上） | 段階的実施を提案 |
| 他スキルとの責務重複 | 責務境界を確認しユーザーに判断を委ねる |

**スコープ**: ユーザーの変更要求理解と精度最大化実装。/sync-skills連携まで。
